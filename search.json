[{"title":"故事的开始","url":"/2023/07/06/%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E5%A7%8B/","content":"写在前面\n从一个想法开始，花一个下午时间，在这个赛博世界，我也有了一隅冠以己名的桃花源。\n\n在故事的前言，我在这里记录维护这里的一些必要的操作，以防这些记忆迷失于未名的角落\n换言之，这是一份写给自己的使用说明\n关于驱动框架：HexoHexo 官网\n在 Hexo 对应根目录右键打开 Git Bash Here，使用 Git Bash 完成命令。\n初始化$ hexo init \n\n需要在空文件夹执行此命令，将克隆 Hexo 的启动配置包我们这里跳过这一步，直接使用 Keep 主题自带启动包，这将省去配置 Keep 主题的过程\n本地生成与上线$ hexo n &quot;title&quot; # (new) 新建以 title 为标题的博客$ hexo clean     # 清除缓存和已生成的静态文件 public$ hexo g         # (generate) 生成网站静态文件$ hexo d         # (deploy) 推送本地 blog 到 github 仓库$ hexo s         # (server) 开启本地预览服务\n\n本地预览的地址一般是 http://localhost:4000/\n关于主题配置：Keep在 Keep 的中文开发文档中可以找到这个主题的一切指南。\n值得留意的是：\n\nHexo 配置文件目录：\\_config.yml\n\n主题配置文件目录：\\source\\_data\\keep.yml\n\n\n参考资料Hexo 最常用的几个命令\n2021最全hexo搭建博客+matery美化+使用\nKeep 主题使用指南 | XPoet’s Blog\n","categories":["知识碎片"],"tags":["Hexo"]},{"title":"指针、数组、字符串的恩怨","url":"/2023/07/07/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%81%A9%E6%80%A8/","content":"指针、数组、字符串的恩怨内存组成为了讲明白不同方式下数组、字符串定义时在内存中的存放方式，需要先对计算机内存分区组成有所了解：\n\n堆区**堆区 (Heap)**：由程序员手动申请释放的内存空间。\n\nC中：malloc()和colloc()函数申请，用free()释放\n\n\n若不用free()释放，容易造成内存泄露（即内存被浪费、耗尽）。\n\n\nptr = (castType*) malloc(size);\n\n  传入参数为内存的字节数，内存未被初始化。\n\nptr = (castType*)calloc(n, size);\n\n  存入参数为内存块数与每块字节数，内存初始化为0。\n\nfree(ptr);\n\n  释放申请的内存。\n\nC++中：new申请，delete释放。new和delete都是操作符\n\n\nint *arr = new int[10];\ndelete[] arr;\n\n栈区**栈区 (Stack)**：由系统管理，存放函数参数与局部变量。函数完成执行，系统自行释放栈区内存。\n静态存储区**静态存储区 (Static Storage Area)**：在编译阶段分配好内存空间并初始化。\n其中全局区存放静态变量（static修饰的变量）、全局变量（具有全局作用域的变量）；常量区存放常量（又称为字面量）。\n常量可分为整数常量（如1000L）、浮点常量（如314158E-5L）、字符常量（如’A’、’\\n’）和字符串常量（如”Hello”）。\n\nconst关键字修饰的的变量无法修改，但存放的位置取决于变量本身是全局变量还是局部变量。当修饰的变量是全局变量，则放在全局区，否则依然在栈区分配。\nstatic关键字修饰的变量存在全局区的静态变量区。\n\n\n常变量与宏定义的概念不同。\n常变量存储在静态存储区，初始化后无法修改。\n宏定义在预处理阶段就被替换。不存在与任何内存区域。\n\n代码区**代码区 (Code Segment)**：存放程序体的二进制代码。\n代码示例/*示例代码*/int a = 0;          //静态全局变量区char *p1;           //编译器默认初始化为NULL，存在静态全局变量区void main()&#123;    int b;                //栈    char s[] = &quot;abc&quot;;     //栈    char *p1 = &quot;123&quot;;     //&quot;123&quot;在字符串常量区，p1在栈区        p2 = (char *)malloc(10); //堆区    strcpy(p2, &quot;123&quot;);       //&quot;123&quot;放在字符串常量区        const int d = 0;      //栈    static int c = 0;     //c在静态变量区，0为文字常量，在代码区    static const int d;   //静态常量区    &#125;\n字符串定义 - 一维方法一char s[10] = &quot;Hello&quot;\n内存：静态存储区上的字面量&quot;Hello&quot;被复制到栈区，数组在栈区上的存储方式为&#39;H&#39;&#39;e&#39;&#39;l&#39;&#39;l&#39;&#39;o&#39;&#39;\\0&#39;，可以通过s[i]修改。但这不会影响到静态存储区上的&quot;Hello&quot;。\n定义与使用：\n#include &lt;stdio.h&gt;void f(char s[10]) &#123;      //等价于char *s    printf(&quot;%s\\n&quot;, s);    s[3] = &#x27;H&#x27;;&#125;int main() &#123;    char s[10] = &quot;LeeHero&quot;;    s[3] = &#x27;Z&#x27;;    printf(&quot;%s\\n&quot;, s);   //输出：LeeZero    printf(&quot;%s\\n&quot;, s+1); //输出：eeZero    printf(&quot;%c\\n&quot;, s[3]);//输出：Z     f(s); //数组名作为函数参数传递时，会退化成指向数组首元素的指针 !IMPORTANT        printf(&quot;%s\\n&quot;, s);   //输出：LeeZero    return 0;&#125; \n\n\n格式控制符 %s 跟随一个地址，并当做是字符串第一个元素对应的地址.\n从该首地址开始解析，直到 &#39;\\0&#39; 结束。\n在这里指的是 s[0] = &#39;H&#39; 的地址。\n\n方法二char *s = &quot;Hello&quot;\n&#x2F;&#x2F; 等价于const char *s = &quot;Hello&quot;\n内存：s是指向字面量&quot;Hello&quot;的指针，字面量在静态内存区，因此该字符串不可被修改。\n定义与使用：\n#include &lt;stdio.h&gt;void f(char s[10]) &#123;       //等价于char *s    printf(&quot;%s\\n&quot;, s);&#125;int main() &#123;    char *s = &quot;LeeHero&quot;;    //s[3] = &#x27;Z&#x27;;          //无法执行     printf(&quot;%s\\n&quot;, s);     //输出：LeeHero    printf(&quot;%s\\n&quot;, s+1);   //输出：eeHero    printf(&quot;%c\\n&quot;, s[3]);  //输出：H     f(s);        return 0;&#125; \n\n字符串定义 - 二维方法一 char s[10][10] = &#123;&quot;Hello&quot;,&quot;World&quot;&#125;\n内存：静态存储区上的字面量&quot;Hello&quot;，&quot;World&quot;被拷贝在栈区，与一维定义方式同理，可以通过语法糖s[i][j]修改字符。\n定义与使用：\n#include &lt;stdio.h&gt;void f(char (*s)[10]) &#123;        //形参s是个指针，指向有10个元素的字符数组                               //把(*s)[10] 改成 s[][10] ，其他不变，最后效果相同    printf(&quot;%s\\n&quot;, s[1]);      //输出：Zero    s[1][0] = &#x27;H&#x27;;             //通过语法糖s[i][j]修改字符    printf(&quot;%s\\n&quot;, s[1]);      //输出：Hero    printf(&quot;%c\\n&quot;, s[0][1]);   //输出：e&#125;int main() &#123;    char s[10][10] = &#123;&quot;Lee&quot;,&quot;Hero&quot;&#125;;    //s[1] = &quot;Hey&quot;;            //无法执行，这种赋值方式仅在初始化时可用    s[1][0] = &#x27;Z&#x27;;    printf(&quot;%s\\n&quot;, s);         //输出：Lee    printf(&quot;%s\\n&quot;, *s+1);      //输出：ee    printf(&quot;%s\\n&quot;, s[0]+1);    //输出：ee        printf(&quot;%c\\n&quot;, *(s[0]+1)); //输出：e    printf(&quot;%c\\n&quot;, s[0][1]);   //输出：e        printf(&quot;%s\\n&quot;, s+1);       //输出：Zero    printf(&quot;%s\\n&quot;, s[1]);      //输出：Zero        f(s);        printf(&quot;%s\\n&quot;, s[1]);      //输出：Hero 这意味着函数内部的修改不是局部生效的    return 0;&#125; \n\n对于打印结果的一些解释：\n · 对二维数组进行操作与输出\n\ns 等价于&amp;s[0]，是指向[存储&quot;Lee&quot;的一维数组]的指针\n\ns+1等价于&amp;s[1]，是指向[存储&quot;Zero&quot;的一维数组]的指针\n\n*s+1等价于(*s)+1，s通过*解析首先得到[一维数组&quot;Lee&quot;] 即指向[一维数组&quot;Lee&quot;的第一个元素&#39;L&#39;的地址]的指针s[0]； 对该指针+1，相当于s[0]+1，使得指针指向[一维数组&quot;Lee&quot;第二个元素&#39;e&#39;的地址]格式控制符%s将该元素看成字符串的首地址，因而打印出&quot;ee&quot;\n\n\n· 二维数组传参\n二维数组主要有两种传参方式（以下两种是函数声明的方式。声明函数后，都是使实参为数组名来调用函数：f(s);）\n\nvoid f(char (*s)[10]) &#123;&#125; —— 一维数组指针作形参\n\n 二维数组名实际上就是指向一维数组的指针。因此这里形参s是个指向行元素的指针，与二维数组名匹配。\n\nvoid f(char s[][10]) &#123;&#125; —— 二维数组指针作形参 对于这种方法，仅二维数组的数组行数可以省略，不可省略列数。f(char s[][])是错误的。\n\n 也就是说，1.和2.方式中都需要正确指定列数。\n\nf(char **s)，f(char *s[])的方式声明函数虽然能编译输出，但编译器可能会出现以下警告信息：[Warning] passing argument 1 of &#x27;f&#x27; from incompatible pointer type[Note] expected &#x27;char **&#x27; but argument is of type &#x27;char (*)[10]&#x27;\n\nP.S. 当然，如果一定要用二维指针作实参f(char **s)，在传参的时候可以将s强制转化：f((char **)s)，函数内部操作元素可以通过*((int *)a+i*10+j)的方式……但何必呢。\n\n\n   如果一定要试试，这里也有个例子：\n      #include &lt;stdio.h&gt;      void f(char **s) &#123;                     //形参s是个二维指针       printf(&quot;%c\\n&quot;, *((char *)s));      //输出：L       printf(&quot;%s\\n&quot;, ((char *)s));       //输出：Lee       printf(&quot;%c\\n&quot;, *((char *)s+10));   //输出：H       printf(&quot;%s\\n&quot;, ((char *)s+10));    //输出：Hero   &#125;      int main() &#123;       char s[10][10] = &#123;&quot;Lee&quot;,&quot;Hero&quot;&#125;;       f((char **)s);                     //“我一定要把s看做二维指针去传参！”       return 0;   &#125;### 方法二`char *s[10] = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;`**内存**：类比`char *s = &quot;Hello&quot;`，这里s是一个指针数组，`s[0]`、`s[1]`是两个指针，分别指向字面量`&quot;Hello&quot;`、`&quot;World&quot;`。指向的内容可以访问，无法修改。**定义与使用**：```c#include &lt;stdio.h&gt;void f(char **s) &#123;   printf(&quot;%s\\n&quot;, s[0]);        //输出：Lee   printf(&quot;%c\\n&quot;, s[0][0]);     //输出：L&#125;int main() &#123;   char *s[10] = &#123;&quot;Lee&quot;,&quot;Hero&quot;&#125;;   printf(&quot;%s\\n&quot;, s[0]);        //输出：Lee（等价于*s）   printf(&quot;%c\\n&quot;, s[0][0]);     //输出：L  （等价于*s[0]）    f(s);   return 0;&#125; \n\n解释：\n数组名作为函数参数传递时，会退化成指向数组首元素的指针。\n当把s作为参数传递给f()函数时，实际上是把指针数组的首地址传递给了f()函数。这样，f()函数中的s就是一个二级指针，它指向了指针数组的第一个元素，也就是第一个字符串的地址。\nf()函数接受一个二级指针作为参数。由此，f()函数中的s[0]和s[0][0]与主函数中的s[0]和s[0][0]含义相同。\n#include &lt;stdio.h&gt;int main() &#123;    \t/* s[10][10]与*s[10]的对比 */        char *s[10] = &#123;&quot;Lee&quot;,&quot;Hero&quot;&#125;;    printf(&quot;%d %d\\n&quot;, sizeof(s), &amp;s);            //输出：80 6487488    printf(&quot;%s\\n&quot;, s);                           //无输出！         printf(&quot;%d %d\\n&quot;, sizeof(s[0]), &amp;s[0]);      //输出：8  6487488    printf(&quot;%s\\n&quot;, s[0]);                        //输出：Lee（等价于*s）        printf(&quot;%d %d\\n&quot;, sizeof(s[0][0]), &amp;s[0][0]);//输出：1  4210692    printf(&quot;%c\\n\\n&quot;, s[0][0]);                   //输出：L  （等价于*s[0]）         char t[10][10] = &#123;&quot;Lee&quot;,&quot;Hero&quot;&#125;;    printf(&quot;%d %d\\n&quot;, sizeof(t), &amp;t);            //输出：100 6487376    printf(&quot;%s\\n&quot;, t);                           //输出：Lee        printf(&quot;%d %d\\n&quot;, sizeof(t[0]), &amp;t[0]);      //输出：10  6487376    printf(&quot;%s\\n&quot;, t[0]);                        //输出：Lee（等价于*t）    \tprintf(&quot;%d %d\\n&quot;, sizeof(t[0][0]), &amp;t[0][0]);//输出：1   6487376    printf(&quot;%c\\n&quot;, t[0][0]);                     //输出：L  （等价于*t[0]）        /* *s[10]内容无法修改 */    t[1][0] = &#x27;Z&#x27;;           //修改二维数组元素    printf(&quot;%s\\n&quot;, t[1]);    //输出：Zero    s[1][0] = &#x27;Z&#x27;;           //程序运行到这里崩溃！    printf(&quot;%s\\n&quot;, s[1]);    //无输出！        return 0;&#125; \n\n对二维数组结构的认识关于二维数组a[i][j] ： 第 $i$ 行第 $j$ 列元素\na[i]：一级指针常量，指第 $i$ 行首元素地址，第 $i$ 行本质为一维数组，a[i]+j是第 $i$ 行第 $j$ 列元素的地址\na：数组指针常量，是二维数组的起始地址，第 $0$ 行的起始地址。\n\n二维数组中的指针等价关系\n优先级：() $&gt;$ ++ $&gt;$ 指针运算符* $&gt;$ +\n\n\n数组结构中对“指针常量”的理解指针常量：不能修改指针所指向的地址，但指向的值可以改变。\n数组名是指针常量。数组名代表数组的首地址，它的值不能改变，也就是说不能让数组名指向其他地址。\n二维数组中a[i][j]中，a[i]可以看做是指向第 $i$ 个一维数组的指针，它的值是第 $i$ 个一维数组的首地址。a[i] 的值不能改变，也就是说不能让 a[i] 指向其他地址。可以类比为指针常量。\n总之，数组结构中各元素地址都是连续且无法更改的。\nchar a[10][10] = &#123;&quot;Lee&quot;, &quot;Hero&quot;&#125;;char *p[10] = &#123;0&#125; //定义指针数组p[0] = a[0];p[1] = a[1]; p[0] = p[1];      //合法a[0] = a[1];      //非法\n指针 vs 数组 内存结构一图流\n图由ECNU CS16级的阳太学长提供~\n\n\nOne More Thing“当指针数组、malloc()动态分配遇见qsort()库函数，关于比较函数cmp(const void *a, const void *b)的迷思”\n利用qsort()函数对一个整数数组进行排序，一般格式如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 比较函数，用于升序排序整数int cmp(const void *a, const void *b) &#123;    int n1 = *(int *)a;    int n2 = *(int *)b;    return n1 - n2;&#125;int main() &#123;    int arr[] = &#123;10, 5, 15, 12, 90, 80&#125;;    int n = sizeof(arr) / sizeof(arr[0]), i;        // 调用qsort库函数，传入数组指针，元素个数，元素大小和比较函数    qsort(arr, n, sizeof(int), cmp);    // 打印排序后的数组    printf(&quot;Sorted array: &quot;);    for (i = 0; i &lt; n; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\\n&quot;);        /* 输出结果：Sorted array: 5 10 12 15 80 90 */        return 0;&#125;\n\n可见，传入cmp()函数的参数是两个void型指针，指向我们需要排序的数组中的每个元素。在上面的例子中，int n1 = *(int *)a;即是将void型指针强制转换成int型指针后用*解地址，得到的便是数组中的元素。\nECNU Online Judge有这样一道题：[邮件地址排序]\n\n题面现接收到一大批电子邮件，邮件地址格式为：用户名@主机域名，要求把这些电子邮件地址做主机域名的字典序升序排序，如果主机域名相同，则做用户名的字典序降序排序。\n输入格式第一行输入一个正整数 $n$，表示共有 $n$ 个电子邮件地址需要排序。接下来 $n$ 行，每行输入一个电子邮件地址（保证所有电子邮件地址的长度总和不超过 $10^6$）。 \n\n对于 $50%$ 的数据，保证 $n \\leqslant 100, |s_i| \\leqslant 100$。\n\n用户名只包含字母数字和下划线，主机域名只包含字母数字和点。\n输出格式按排序后的结果输出 $n$ 行，每行一个电子邮件地址。\n\n为节省内存，通过比较逆天的试例，考虑用指针与malloc()动态内存管理存储邮件地址：\n\n为了和这篇博客主题契合，这里只介绍这种数据存储结构的实现方式与cmp()的设计方法：\n/* 数据输入 */int T; //要输入的邮件个数scanf(&quot;%d&quot;, &amp;N);//建立指针数组 emailchar **email;email = (char **)malloc(N * sizeof(char*))； //相当于实现了char *email[N]//使指针数组 email 中的每个指针元素都指向一个邮件地址字符串for (int i = 0; i &lt; N; i++) &#123;    scanf(&quot;%s&quot;, s);  //读取一个字符串    LEN = strlen(s); //获取字符串长度    char p = (char *)malloc((LEN+1) * sizeof(char)); //分配每个字符串的存储空间    strcpy(p, s);    //把字符串复制到p处，这两行相当于实现了char p[LEN+1] = &#123;s&#125;    *(email + i) = p;    //使指针数组 email 中的指针元素指向 p ，p也是个指针，但借助malloc()动态分配，实现了字符串的功能&#125;\n\n数据输入完毕后最终实现的效果，类似于char *email[50] = &#123;&quot;123@qq.com&quot;, &quot;456@ecnu.edu.com&quot;&#125;的定义方式，只是一维字符数组的长度是借助malloc()动态分配的，并不是个定值。\n数据输入完毕，我们现在得到了一个名为email的指针数组，数组里的每个元素都是一个指针，指向共 $N$ 个字符串。\n设计cmp()时，传入cmp()函数的参数是两个void型指针，指向我们需要排序的数组中的每个元素。因此，void型指针指向一级指针，这样的void型指针就是二维指针——char **。\nint cmp (const void *a, const void *b) &#123;    char *p1 = *((char **)a);    char *p2 = *((char **)b); //对二级指针a、b进行一次解地址，得到的就是一级指针p1，p2                 //通过 *(p1+i) *(p2+i) 操作就可以解析到[一级指针所指字符串]的每个字符                              //从而做进一步的比较处理    /* 后续省略 */    return ret;&#125;\n以上。如有疑义欢迎提出。\n","categories":["知识碎片"],"tags":["C/C++"]}]