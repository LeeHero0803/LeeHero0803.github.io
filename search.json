[{"title":"blog-test","url":"/2023/07/06/blog-test/","content":"编思小抄数据范围\n\n\n数据类型\n范围（2^x^）\n最大范围（10^x^）\n格式化控制符\n\n\n\nunsigned int\n[0,2^32^-1]\n10^9^\n%u\n\n\nint\n[-2^31^,2^31^-1]\n10^9^\n%d\n\n\nlong long\n[-2^63^,2^63^-1]\n10^18^\n%lld\n\n\nunsigned long long\n[0,2^64^-1]\n10^19^\n%llu\n\n\n\nASCII码\n\n\nDec\nChar\nDec\nChar\nDec\nChar\nDec\nChar\nDec\nChar\nDec\nChar\n\n\n\n32\n\n48\n0\n64\n@\n80\nP\n96\n`\n112\np\n\n\n33\n!\n49\n1\n65\nA\n81\nQ\n97\na\n113\nq\n\n\n34\n“\n50\n2\n66\nB\n82\nR\n98\nb\n114\nr\n\n\n35\n#\n51\n3\n67\nC\n83\nS\n99\nc\n115\ns\n\n\n36\n$\n52\n4\n68\nD\n84\nT\n100\nd\n116\nt\n\n\n37\n%\n53\n5\n69\nE\n85\nU\n101\ne\n117\nu\n\n\n38\n&amp;\n54\n6\n70\nF\n86\nV\n102\nf\n118\nv\n\n\n39\n‘\n55\n7\n71\nG\n87\nW\n103\ng\n119\nw\n\n\n40\n(\n56\n8\n72\nH\n88\nX\n104\nh\n120\nx\n\n\n41\n)\n57\n9\n73\nI\n89\nY\n105\ni\n121\ny\n\n\n42\n*\n58\n:\n74\nJ\n90\nZ\n106\nj\n122\nz\n\n\n43\n+\n59\n;\n75\nK\n91\n[\n107\nk\n123\n{\n\n\n44\n,\n60\n&lt;\n76\nL\n92\n\\\n108\nl\n124\n|\n\n\n45\n-\n61\n=\n77\nM\n93\n]\n109\nm\n125\n}\n\n\n46\n.\n62\n&gt;\n78\nN\n94\n^\n110\nn\n126\n~\n\n\n47\n/\n63\n?\n79\nO\n95\n_\n111\no\n\n\n\n\n\n数组传参void f(char s[10]); // f(char *s)int main() {    char s[10] = \"LeeHero\";    f(s);    return 0;}\n\nvoid f(char s[][10]); // f(char (*s)[10])int main() {    char s[5][10] = {\"Lee\",\"Hero\"};    f(s);    return 0;}\n\n\n代码模板GCD/LCMint gcd(int a, int b) { return b&gt;0?gcd(b,a%b):a; }int lcm(int a, int b) { return a/gcd(a,b)*b; }\n\n\n\n排序一般模板int cmp(const void *a, const void *b) {    int x1 = *(int *)a;    int x2 = *(int *)b;    return x1-x2;}int main() {    int arr[] = {10, 5, 15, 12, 90, 80};    int n = sizeof(arr) / sizeof(arr[0]), i;    qsort(arr, n, sizeof(int), cmp); // &lt;- QSORT    for (i = 0; i &lt; n; i++)        printf(\"%d \", arr[i]);    printf(\"\\n\");    return 0;}\n\n结构体排序typedef struct {\tchar usr[20]; char dom[20];} EMAIL;int cmp(const void *a, const void *b) {\tEMAIL *A = (EMAIL *)a;\tEMAIL *B = (EMAIL *)b;\tif (strcmp(A -&gt; dom, B -&gt; dom) == 0) {\t\treturn strcmp(B -&gt; usr, A -&gt; usr);\t} else {\t\treturn strcmp(A -&gt; dom, B -&gt; dom);\t}}int main() {\tEMAIL *data = 0;\tint T; scanf(\"%d\", &amp;T);    EMAIL *data = (EMAIL *)malloc(sizeof(EMAIL)*(T+10));\tfor (int i = 0; i &lt; T; i++) {\t\tchar ads[50] = {0};\t\tscanf(\"%s\", &amp;ads);\t\tstrcpy((data+i) -&gt; usr, GetUsr(ads));\t\tstrcpy((data+i) -&gt; dom, GetDom(ads));\t}\tqsort(data, T, sizeof(EMAIL), cmp); // &lt;- QSORT\tfor (int i = 0; i &lt; T; i++)\t\tprintf(\"%s@%s\\n\", data[i].usr, data[i].dom);\treturn 0;}\n\n二维定长数组排序int cmp(const void *a, const void *b) {\tchar *n1 = (char *)a;    char *n2 = (char *)b;\treturn myStrCmp(n1, n2);}int main() {    char c; int i = 0; char words[120][100] = {0};    scanf(\"%s\", words[i++]);    while ((c = getchar()) != '\\n') { scanf(\"%s\", words[i++]); }    qsort(words, i, sizeof(words[0]), cmp); // &lt;- QSORT    for (int j = 0; j &lt; i; j++) printf(\"%s \", words[j]);    printf(\"\\n\");\treturn 0; }\n\n二维动态数组排序int cmp(const void *a, const void *b) {\tint *n1 = *((int **)a);\tint *n2 = *((int **)b);\treturn *(n1+1) - *(n2+1); //cmp car[x][1] &amp; car[y][1]}                             //belike ((int *)a)[1]-((int *)b)[1]int main() {\tint n, t; scanf(\"%d %d\",&amp;n,&amp;t);\tint **car = (int **)malloc(n*sizeof(int*));\tfor (int i = 0; i &lt; n; i++) {\t\tint *p = (int *)malloc(3*sizeof(int));\t\t*(car+i) = p;\t}    qsort(car, n, sizeof(car[0]), cmp); // &lt;- QSORT    return 0;}\n\n\n\nint cmp(const void *a, const void *b) {    char *p1 = *((char **)a);    char *p2 = *((char **)b);    //通过 *(p1+i) *(p2+i) 操作就可以解析到[一级指针所指字符串]的每个字符    //从而做进一步的比较处理    /* 后续省略 */    return ret;}int main() {\tint N; scanf(\"%d\", &amp;N); char **email;    email = (char **)malloc(N * sizeof(char*))； //char *email[N]    for (int i = 0; i &lt; N; i++) {        scanf(\"%s\", s);        LEN = strlen(s);        p = (char *)malloc((LEN+1) * sizeof(char));        strcpy(p, s);        *(email + i) = p;    }    qsort(email, N, sizeof(email[0]), cmp); // &lt;- QSORT    for (int i = 0; i &lt; n; i++) printf(\"%s\\n\",*(email+i));    return 0;}\n\n\n\n大整数#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct {\tint cnt, v[1000];\t//个位在前存储} BIGINT;BIGINT int2BIG(int x) { //int转BIGINT\tBIGINT r = {0, {0}};\twhile (x &gt; 0) {\t\tr.v[r.cnt++] = x % 10;\t\tx /= 10;\t}\treturn r;}BIGINT char2BIG(char *s) {\tBIGINT R = {0, {0}};\tint len = strlen(s);\tint i;\tR.cnt = len;\tfor (i = len - 1; i &gt;= 0; i--) {\t\tR.v[len - 1 - i] = s[i] - '0';\t}\treturn R;}void printBIG(BIGINT a) {\tif (a.cnt == 0) {\t\tprintf(\"0\\n\");\t\treturn;\t}\tint len = a.cnt, i;\twhile (a.v[len - 1] == 0)\t\tlen--;\tfor (i = len - 1; i &gt;= 0; i--)\t\tprintf(\"%d\", a.v[i]);\tprintf(\"\\n\");}BIGINT mul(BIGINT S, BIGINT T) {\t//两个大整数相乘\tif (S.cnt == 0 || T.cnt == 0)\t\treturn int2BIG(0);\tBIGINT R = {S.cnt + T.cnt, {0}};\tfor (int i = 0; i &lt; T.cnt; i++) {\t\tint t, k, j;\t\tint carry = 0;\t\tfor (j = 0; j &lt; S.cnt; j++) {\t\t\tt = S.v[j] * T.v[i] + carry + R.v[i + j];\t\t\tR.v[i + j] = t % 10;\t\t\tcarry = t / 10;\t\t}\t\tk = i + j;\t\twhile (carry &gt; 0) {\t\t\tt = carry + R.v[k];\t\t\tR.v[k] = t % 10;\t\t\tcarry = t / 10;\t\t\tk++;\t\t}\t}\tif (R.v[S.cnt + T.cnt - 1] == 0)\t\tR.cnt--; //最高位0不统计在一个大整数的位数中\treturn R;}BIGINT add(BIGINT S, BIGINT T) {\t//两个大整数相加\tBIGINT R = {0, {0}};\tint i, carry = 0;\tfor (i = 0; i &lt; S.cnt &amp;&amp; i &lt; T.cnt; i++) {\t\tint temp = (S.v[i] + T.v[i] + carry);\t\tR.v[i] = temp % 10;\t\tcarry = temp / 10;\t}\twhile (i &lt; S.cnt) {\t\tint temp = S.v[i] + carry;\t\tR.v[i++] = temp % 10;\t\tcarry = temp / 10;\t}\twhile (i &lt; T.cnt) {\t\tint temp = T.v[i] + carry;\t\tR.v[i++] = temp % 10;\t\tcarry = temp / 10;\t}\tif (carry) {\t\tR.v[i++] = carry % 10;\t}\tR.cnt = i;\treturn R;}int cmp(BIGINT S, BIGINT T) {\t//两个大整数的比较\tint n = (S.cnt &gt; T.cnt) ? S.cnt : T.cnt;\tfor (int i = n - 1; i &gt;= 0; i--)\t\tif (*(S.v + i) &gt; *(T.v + i))\t\t\treturn 1;\t\telse if (*(S.v + i) &lt; * (T.v + i))\t\t\treturn -1;\treturn 0;}void SUB(BIGINT *S, BIGINT *T, BIGINT *result) { //大数减小数\tint n = (S-&gt;cnt &gt; T-&gt;cnt) ? S-&gt;cnt : T-&gt;cnt;\tresult-&gt;cnt = n;\tint carry = 0, i;\tfor (i = 0; i &lt; n; i++) {\t\tif ((*(S-&gt;v + i) + carry) &lt; (*(T-&gt;v + i))) {\t\t\t*(result-&gt;v + i) = 10 + *(S-&gt;v + i) + carry - *(T-&gt;v + i);\t\t\tcarry = -1;\t\t} else {\t\t\t*(result-&gt;v + i) = *(S-&gt;v + i) + carry - *(T-&gt;v + i);\t\t\tcarry = 0;\t\t}\t}\tfor (int i = n - 1; i &gt;= 0 &amp;&amp; !result-&gt;v[i]; i--)\t\tresult-&gt;cnt--;}BIGINT BIGSUB(BIGINT S, BIGINT T, int *sign) {\tBIGINT R = {0, {0}};\t*sign = 1;\tif (cmp(S, T) &gt;= 0) {\t\t*sign = 1;\t\tSUB(&amp;S, &amp;T, &amp;R);\t} else {\t\t*sign = -1;\t\tSUB(&amp;T, &amp;S, &amp;R);\t}\treturn R;}int main() {\tchar s1[600], s2[600];\tBIGINT a = {0, {0}}, b = {0, {0}}, c = {0, {0}};\tint sign = 1;\twhile (scanf(\"%s %s\", s1, s2) != EOF) {\t\ta = char2BIG(s1);\t\tb = char2BIG(s2);\t\tc = BIGSUB(a, b, &amp;sign);\t\tif (sign == -1)\t\t\tprintf(\"-\");\t\tprintBIG(c);\t}\treturn 0;}\n\n\n代码示例进制转换#include &lt;stdio.h&gt;#include &lt;string.h&gt;const char mod[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";int A2dec(char *sol, int A) {\tint len = strlen(sol);\tint weight = 1;\tint ans = 0;\tfor (int i = 0; i &lt; len; i++) {\t\tif (sol[i] &gt;= 'a' &amp;&amp; sol[i] &lt;= 'z') sol[i] -= 'a'-'A';\t}\tfor (int i = len-1; i &gt; -1; i--) {\t\tint j;\t\tfor (j = 0; j &lt; strlen(mod); j++) if (mod[j] == sol[i]) break;\t\tans += j*weight;\t\tweight *= A;\t}\treturn ans;}void dec2B(int dec,int B,char *ans) {\tchar temp[50]; int i = 0;\tif (dec == 0) temp[i++] = '0';\twhile (dec) {\t\ttemp[i++] = mod[dec%B];\t\tdec /= B;\t}\tint k = 0;\tfor (int j = i-1; j &gt; -1; j--) {\t\tans[k++] = temp[j];\t}\tans[k] = '\\0';}int main() {\tint A, B; // A为起始，B为目标\tchar sol[50]; // 转换数据\tscanf (\"%d %s %d\", &amp;A, &amp;sol, &amp;B); \tint dec;\tdec = A2dec(sol,A);\tchar ans[50];\tdec2B(dec,B,ans);\tprintf(\"%s\", ans);\treturn 0;} \n\n台阶走法#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef unsigned long long int ull;#define SIZE 500typedef struct {\tint cnt, v[SIZE];} BIGINT;void printBIG(BIGINT b) {\tfor (int i = 0; i &lt; b.cnt; i++)\t\tprintf(\"%d\", b.v[b.cnt - 1 - i]);\tprintf(\"\\n\");}BIGINT int2BIG(int x) {\tBIGINT r = {0, {0}};\tint flag = 0; //对0特判，但是没做0的add和mul \twhile (x) {\t\tr.v[r.cnt++] = x % 10;\t\tx /= 10;\t\tflag = 1;\t}\tif (flag == 0) r.cnt = 1;\treturn r;}BIGINT string2BIG(char *s) {\tBIGINT r = {0, {0}};\tr.cnt = strlen(s);\tfor (int i = 0; i &lt; r.cnt; i++)\t\tr.v[r.cnt - 1 - i] = s[i] - '0';\treturn r;}BIGINT mul(BIGINT S, BIGINT T) {\tif (S.cnt == 0 || T.cnt == 0)\t\treturn int2BIG(0);\tBIGINT R = {S.cnt + T.cnt, {0}};\tfor (int i = 0; i &lt; T.cnt; i++) {\t\tint t, k, j;\t\tint carry = 0;\t\tfor (j = 0; j &lt; S.cnt; j++) {\t\t\tt = S.v[j] * T.v[i] + carry + R.v[i + j];\t\t\tR.v[i + j] = t % 10;\t\t\tcarry = t / 10;\t\t}\t\tk = i + j;\t\twhile (carry) {\t\t\tt = carry + R.v[k];\t\t\tR.v[k] = t % 10;\t\t\tcarry = t / 10;\t\t\tk++;\t\t}\t}\tif (R.v[S.cnt + T.cnt - 1] == 0)\t\tR.cnt--;\treturn R;}BIGINT add(BIGINT S, BIGINT T) {\tBIGINT R = {0, {0}};\tint i, carry = 0;\tfor (i = 0; i &lt; S.cnt &amp;&amp; i &lt; T.cnt; i++) {\t\tint temp = (S.v[i] + T.v[i] + carry);\t\tR.v[i] = temp % 10;\t\tcarry = temp / 10;\t}\twhile (i &lt; S.cnt) {\t\tint temp = S.v[i] + carry;\t\tR.v[i++] = temp % 10;\t\tcarry = temp / 10;\t}\twhile (i &lt; T.cnt) {\t\tint temp = T.v[i] + carry;\t\tR.v[i++] = temp % 10;\t\tcarry = temp / 10;\t}\tif (carry)\t\tR.v[i++] = carry % 10;\tR.cnt = i;\treturn R;}//ull hash[101] = {0};BIGINT hash[101];int main() {\tfor (int i = 0; i &lt; 101; i++) {\t\tif (i &lt;= 1)\t\t\t//hash[i] = 1;\t\t\thash[i] = int2BIG(1);\t\telse if (i == 2)\t\t\t//hash[i] = 2;\t\t\thash[i] = int2BIG(2);\t\telse if (i == 3)\t\t\t//hash[i] = 4;\t\t\thash[i] = int2BIG(4);\t\telse if (i == 4)\t\t\t//hash[i] = 8;\t\t\thash[i] = int2BIG(8);\t\telse {\t\t\t//hash[i] = hash[i - 1] + hash[i - 2] + hash[i - 3] + hash[i - 4];\t\t\tBIGINT r1 = add(hash[i - 1], hash[i - 2]);\t\t\tBIGINT r2 = add(hash[i - 3], hash[i - 4]);\t\t\thash[i] = add(r1, r2);\t\t}\t}\tint T;\tscanf(\"%d\", &amp;T);\tfor (int i = 0; i &lt; T; i++) {\t\tint ptA, ptB; //path A/B\t\tint stB, stS; //Start Building/Step\t\tint edB, edS; //End Building/Step\t\tscanf(\"%d %d %d %d %d %d\", &amp;ptA, &amp;ptB, &amp;stB, &amp;stS, &amp;edB, &amp;edS);\t\t//ull ans;\t\tBIGINT ans = {0, {0}};\t\tif (stB == edB) {\t\t\tif (ptA &lt; stS || ptB &gt; edS) {\t\t\t\tans = hash[edS - stS];\t\t\t} else {\t\t\t\t//ans = hash[edS - ptB] * hash[ptB - ptA] * hash[ptA - stS] + hash[edS - stS];\t\t\t\tBIGINT r1 = mul(hash[edS - ptB], hash[ptB - ptA]);\t\t\t\tBIGINT r2 = mul(r1, hash[ptA - stS]);\t\t\t\tans = add(r2, hash[edS - stS]);\t\t\t}\t\t} else if (stB != edB) {\t\t\tif (ptA &lt; stS &amp;&amp; ptB &gt; edS || ptA &gt; edS || ptB &lt; stS) { \t\t\t/*B走廊在起点下方；A走廊在终点上方；AB包夹起点和终点*/ \t\t\t\t//ans = 0;\t\t\t\tans = int2BIG(0);\t\t\t} else if (ptA &lt; stS) {\t\t\t\t//ans = hash[ptB - stS] * hash[edS - ptB];\t\t\t\tans = mul(hash[ptB - stS], hash[edS - ptB]);\t\t\t} else if (ptB &gt; edS) {\t\t\t\t//ans = hash[ptA - stS] * hash[edS - ptA];\t\t\t\tans = mul(hash[ptA - stS], hash[edS - ptA]);\t\t\t} else {\t\t\t\t//ans = hash[ptB - stS] * hash[edS - ptB] + hash[ptA - stS] * hash[edS - ptA];\t\t\t\tBIGINT r1 = mul(hash[ptB - stS], hash[edS - ptB]);\t\t\t\tBIGINT r2 = mul(hash[ptA - stS], hash[edS - ptA]);\t\t\t\tans = add(r1, r2);\t\t\t}\t\t}\t\t//printf(\"case #%d:\\n%llu\\n\", i, ans);\t\tprintf(\"case #%d:\\n\", i); printBIG(ans);\t}\treturn 0;}\n\n皇后问题#include &lt;stdio.h&gt;void Danger(int i, int j, char map[][200], int n) {\t/*Q的可攻击路径标记为D，遇到另外的Q则停止，并且把Q变为O*/\tfor (int k = i+1; k &lt; n; k++) { // 下 \t\tif (map[k][j] == 'E') map[k][j] = 'D';\t\tif (map[k][j] == 'Q') { map[k][j] = 'O'; break; }\t}\tfor (int k = i-1; k &gt; -1; k--) { // 上 \t\tif (map[k][j] == 'E') map[k][j] = 'D';\t\tif (map[k][j] == 'Q') { map[k][j] = 'O'; break; }\t}\tfor (int k = j+1; k &lt; n; k++) { // 右 \t\tif (map[i][k] == 'E') map[i][k] = 'D';\t\tif (map[i][k] == 'Q') { map[i][k] = 'O'; break; }\t}\tfor (int k = j-1; k &gt; -1; k--) { // 左 \t\tif (map[i][k] == 'E') map[i][k] = 'D';\t\tif (map[i][k] == 'Q') { map[i][k] = 'O'; break; }\t}\tfor (int k = i+1, l = j+1; k &lt; n &amp;&amp; l &lt; n; k++, l++) { // 右下 \t\tif (map[k][l] == 'E') map[k][l] = 'D';\t\tif (map[k][l] == 'Q') { map[k][l] = 'O'; break; }\t}\tfor (int k = i-1, l = j+1; k &gt; -1 &amp;&amp; l &lt; n; k--, l++) { // 右上 \t\tif (map[k][l] == 'E') map[k][l] = 'D';\t\tif (map[k][l] == 'Q') { map[k][l] = 'O'; break; }\t}\tfor (int k = i-1, l = j-1; k &gt; -1 &amp;&amp; l &gt; -1; k--, l--) { // 左上 \t\tif (map[k][l] == 'E') map[k][l] = 'D';\t\tif (map[k][l] == 'Q') { map[k][l] = 'O'; break; }\t}\tfor (int k = i+1, l = j-1; k &lt; n &amp;&amp; l &gt; -1; k++, l--) { // 左上 \t\tif (map[k][l] == 'E') map[k][l] = 'D';\t\tif (map[k][l] == 'Q') { map[k][l] = 'O'; break; }\t}}void Safe(int i, int j, char map[][200], int n);\t/*q的移动路径上若为E，标记为S，遇到Q变为S后停止，遇到O直接停止*/int SafeCnter(char map[][200], int n) {\t/*统计地图中S的数目*/\tint cnt = 0;\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++) if(map[i][j] == 'S') cnt++; \t}\treturn cnt;}void Show(char map[][200], int n)；int main() {\tint n; char c;\tchar map[200][200];\tint Qpos[20000][2]; int Qind = 0;\tint qpos[2];\tscanf(\"%d\", &amp;n);\tc = getchar();\t/*读取地图*/\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++) {\t\t\tscanf(\"%c\", &amp;map[i][j]);\t\t\tif (map[i][j] == 'Q') {\t\t\t\tQpos[Qind][0] = i; Qpos[Qind][1] = j;\t\t\t\tQind++;\t\t\t}\t\t\tif (map[i][j] == 'q') {\t\t\t\tqpos[0] = i; qpos[1] = j;\t\t\t}\t\t}\t\tc = getchar();\t}\t//printf(\"Qind:%d\\n\", Qind);\t/*标记危险格子*/\tfor (int i = 0; i &lt; Qind; i++) {\t\tint Qi = Qpos[i][0], Qj = Qpos[i][1];\t\t//printf(\"Qi:%d Qj:%d\\n\",Qi, Qj);\t\tDanger(Qi, Qj, map, n);\t}\tSafe(qpos[0], qpos[1], map, n);\tprintf(\"%d\\n\",SafeCnter(map, n)); \treturn 0;}\n"},{"title":"blog test II","url":"/2023/07/06/blog-test-II/","content":"ECNU - Linear Algebra[1.x] 知识点提纲[1.1.x] 行列式\n二阶行列式计算\n主对角线  副对角线\n\n\n三角行列式计算\n上/下三角：主对角线元素乘积\n行列式性质：\n某行/列的k倍加到另一行/列，行列式值不变\n某行/列所有元素公因子可以提到行列式外\n交换两行/列，行列式值变号\n\n\n\n\n行和相等行列式计算\n把后面所有列加到第一列，提公因子，使得第一列全部变成1\n行变换，化成三角行列式\n\n\n范德蒙德行列式计算\n特点：\n第一行/列元素全为 \n每一列/行元素均为等比数列，且公比元素在第  行/列\n结果为公比元素作差再相乘\n\n\n\n\n爪形行列式计算\n通过提公因子，将主对角线第  个元素化为 \n化为三角行列式\n\n\n余子式、代数余子式\n余子式  无符号；代数余子式  有符号\n行列式  某行/列元素乘以相应代数余子式后求和\neg. 求  \n把行列式  中  分别替换为对应系数  后再求行列式即可。\n\n\neg. 求  \n通过  和  的代换，将原式化为： \n再系数替换，求新的行列式\n\n\n\n\n用拆和的方法计算行列式\n当行列式某行/列为两数之和，行列式可分解为两行列式之和（其余行/列元素不变）\n当行列式某两行/列元素成比例，行列式等于零\n\n\n拉普拉斯公式计算行列式\n\n若不符合主对角线形式的拉普拉斯公式，可以通过行/列调换使得其变成主对角线形式\n\n\n\n\n[1.2.x] 矩阵\n矩阵的乘法\n\n[Tip]矩阵乘法不满足交换律，满足分配律\n\n\n抽象矩阵求逆矩阵\n\n[Key]根据条件出发，找出相乘为E的矩阵\n[Key]拆出来 or 长除法\n[Tip]对  而言，根据  找出相应的 \n\n\n数字型求逆矩阵\n\n[Key]利用行变化法求逆矩阵：行变换\n[Key]二阶矩阵逆矩阵秒杀“两调一除”： ; \n[Tip]方阵  可逆  \n\n\n求解矩阵方程\n\n\n\n\n前提都是 、 存在\n\n\n$AA^*=A^A=|A|EA^=|A|A^{-1}$\n用来解决矩阵方程中的 \n\n\n[Tip]行列式外系数乘进去是一行/一列；矩阵外系数乘进去是每一个元素\n\n\n方阵的行列式\n\n ;  ;  ; \n\n，就是说不能把里面的各个方阵分开求行列式再加和\n[Tip]提出来行列式内系数  的时候也要注意，若方阵是  阶，提出来的是 \n\n\n方阵的转置与逆Misplaced & (A^T)^T &amp;=&amp; A &amp;;&amp; (A^{-1})^{-1}&amp;=&amp;A\\ (A+B)^T &amp;=&amp; A^T + B^T &amp;;&amp; &amp;/\\ (kA)^T &amp;=&amp; kA^T &amp;;&amp; (kA)^{-1}&amp;=&amp;\\frac{1}{k}A^{-1}\\ (AB)^T &amp;=&amp; B^TA^T &amp;;&amp; (AB)^{-1}&amp;=&amp;B^{-1}A^{-1}\\ &amp;&amp;&amp;&amp;(A^T)^{-1}&amp;=&amp;(A^{-1})^T \n\n矩阵的秩\n\n初等行变换阶梯型，则 非零行数\n满秩矩阵  非奇异矩阵  矩阵可逆  对应行列式不为零\n秩也是矩阵中线性无关行（或列）的最大个数\n\n\n矩阵秩的不等式Misplaced &   r(AB)&amp;\\leq &amp; \\min{r(A),r(B)}\\   r(A+B)&amp;\\leq &amp; r(A)+r(B)\\   r(A|B)&amp;\\leq &amp; r(A)+r(B)\\   r(A)+r(B)&amp;\\leq &amp; r(AB)+n \n\n\n\n对 \n\n\n\n对 \n\n\n\n若 \n\n\n\n若 \n\n\n\n若 \n\n[1.3.x] 向量组的线性相关\n判别向量组线性相关性-数字型\n\n[Key]两个向量  相关   与  对应成比例  方阵 \n[Key]多个向量  相关（无关）  $\\left{ 方阵非方阵 \\right.$\n\n\n判别向量组线性相关性-抽象型\n\n[Key·1]逆向思维，复杂矩阵抽离成简单分块矩阵相乘：\neg. \neg. \n\n\n[Key·2]  线性无关，则：$\\left{相关无关 \\right.$\n换言之：$\\left{无关组不可逆阵相关无关组可逆阵无关 \\right.$\n\n\n\n\n求向量组的秩和极大无关组\n\n[Key]  矩阵  的阶梯型中非零行数\n[Key] 的极大无关组一般取阶梯型“拐弯处”所在列向量\neg. ，则 可以构成一个极大无关组\n\n\n\n\n\n[1.4.x] 线性方程组\n齐次方程组  的求解\n\n$$A_{m\\times n}X=O\\Longrightarrow\\left{ 只有零解唯一解有非零解无穷解\\right.$$\n\n[Tip]系数矩阵的列数（ 中的 ）就是未知数的个数\n\n\n基础解系：当  有无穷解时，解集的极大无关组为基础解系\n\n[Key]基础解系含解向量个数为 \n[Tip]  基础解系含解向量个数  未知数个数有效方程个数自由变量个数\n\n\n基础解系求法：\n\n把系数矩阵化为行最简形。\neg. \n\n\n“非拐弯处变量”作为自由变量，有  个。\neg. , \n\n\n通解 为任意常数\n\n\n\n\n非齐次方程组  的求解\n\n有无穷解有唯一解无解\n\n非齐次方程组通解  齐次方程组通解  非齐次方程组特解\n\n齐次方程组通解：用1.的方法\n非齐次方程组特解：一般令1.中自由变量为0，导出 （实际上就对应行最简型的最后一列补0）\n\n\n 通解为 \n\n\n\n带参方程组求解\n\n翻译条件，归纳为无穷解/唯一解/无解从而得出相应方程关系，再根据1.2.知识求解。\n\n\n\n\n[1.5.x] 矩阵的对角化\n数值型-特征值与特征向量\n\n求  特征值方法：由特征方程  解得  即为  的特征值（ 称为特征多项式）\n求  特征向量（对应特征值为 ）： 的基础解系\n\n\n抽象型-特征值与特征向量\n\n已知抽象矩阵的特征值，求关于抽象矩阵的新矩阵特征值\n\n关于  的性质：\n\n几何重数： 是  的  重特征值，称  的几何重数是   代数重数： 对应  个线性无关的特征向量（ 为  的维数），称  的代数重数为 \n\n几何重数不大于代数重数（）\n\n\n若  的特征值为 \n\n对应特征向量  线性无关\n【 的行列式等于特征值之积】\n，\n 至少有一个特征值为0   的特征值均非0\n\n\n【 的迹等于特征值之和】迹：矩阵主对角线元素和\n\n\n\n\n\n若  是  特征值， 是对应特征值的特征向量，有 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特征值\n\n\n\n\n$\\displaystyle\\frac{\nA\n}{\\lambda}$\n\n\n特征向量\n\n\n\n\n\n不确定\n\n\n\n\n\n\n相似矩阵\n\n存在可逆矩阵  使得 ，称  相似于 ，记为 \n性质\n自反性：\n对称性：\n传递性：\n若 ，则：\n 等价（ 等价  经过若干次初等行变换，使得  （可逆））\n 有相同特征值、行列式与迹\n 有相同的秩\n\n\n\ne.g. \n\n\n\n\n\n\n\n\n\n矩阵的相似对角化\n\n若存在可逆矩阵  ，使 （  为对角矩阵），则称  可相似对角化（此时有 ）\n\n判定  阶矩阵  能否相似对角化\n\n充要条件： 有  个线性无关的特征向量\n如果一个矩阵的特征值都是不同的，那么它一定可以相似对角化\n\n如果一个矩阵每个特征值的代数重数（特征多项式中的重数）等于几何重数（对应该特征值的特征向量的维数）那么它一定可以相似对角化\n\n如果一个矩阵的某个特征值的代数重数大于它的几何重数，那么它一定不能相似对角化\n\n\n\n\n\n把  相似对角化的步骤\n\n求  特征值 \n\n求对应特征向量 \n\n令 ，则\n\n\n\n\n\n实对称矩阵\n\n实：矩阵元素为实数；对称：方阵，以主对角线为轴对称\n\n特征值为实数；对应特征值为实向量\n\n非实对称矩阵就不一定。如  对应特征方程为 ，对应的特征值为虚根。\n\n\n互不相等的特征值对应的特征向量间两两正交\n\n所有特征值的几何重数等于代数重数\n\n\n\n实对称矩阵的相似对角化·利用相似矩阵\n\nn阶实对称矩阵  必可对角化，且一定存在正交矩阵  ，使得 \n\n正交矩阵  的性质\n\n\n\n\n\n\n\n\n\n\n把对称阵  用正交阵  相似对角化的步骤\n\n求  特征值 \n\n求对应特征向量 \n\n把  中不正交的矩阵正交化：\n\n若  不正交，令\n\n  Misplaced &   \\beta_1=&amp;\\alpha_1\\   \\beta_2=&amp;\\alpha_2-\\displaystyle\\frac{(\\alpha_2,\\beta_1)}{(\\beta_1,\\beta_1)}\\beta_1\\   (\\beta_3=&amp;\\alpha_3-\\displaystyle\\frac{(\\alpha_3,\\beta_1)}{(\\beta_1,\\beta_1)}\\beta_1-\\frac{(\\alpha_3,\\beta_2)}{(\\beta_2,\\beta_2)}\\beta_2)\\   &amp;…       \\nonumber   \n\n单位化所有特征向量，得   \n\n令 ，则  \n\n\n\n\n\n\n\n单矩阵关系\n\n对合矩阵 \n幂零矩阵 \n对称矩阵 \n反对称矩阵 \n正交矩阵 \n初等矩阵 通过一次初等行/列变换就可以得到  的矩阵\n\n多矩阵关系\n\n等价\n\n定义：\n\n向量组等价：两个向量组能够相互线性表出  两向量组维数相同（包含向量数不一定相同）\n\n矩阵等价：两个同型矩阵能够通过初等变换相互转化  两同型矩阵秩相等\n\n\n\n相似\n\n定义：\n本质： 和  是在不同基中的同一个线性变换\n判定：着眼于特征值与特征向量\n【特征值相等】\n矩阵的迹是否相等\n矩阵的秩是否相等（求解行列式）\n矩阵特征值是否相等\n【特征值对应的特征向量相等】\n 和  的秩是否相等（看多重特征根）\n\n\n\n\n合同\n\n定义：\n判定： 均为实数域上的n阶对称矩阵，则A与B在实数域上合同等价于A与B有相同的正、负惯性指数（即正、负特征值的个数相等）\n\n\n\n\n[1.6.x] 二次型\n二次型的矩阵表示\n\n二次型矩阵的三要素\n\n\n 的主对角元素为平方项系数\n 的非主对角元素为交叉项系数的一半\n\n\ne.g.$$f(x_1,x_2)=&amp;2x_1^2-x_2^2+6x_1x_2\\=&amp;(x_1,x_2)\\=&amp;x^TAx\\\nf(x_1,x_2,x_3)=&amp;x_1^2+3x_2^2-x_3^2+2x_1x_2+2x_1x_3-3x_2x_3\\=&amp;(x_1,x_2,x_3)\\=&amp;x^TAx\\\\nonumber$$\n\n\n\n化二次型为标准型\n\n只有平方项的二次型称为标准形\n\n配方法：\n\nMisplaced & a^2+2ab&amp;=&amp;a^2+2ab+b^2-b^2&amp;=&amp;(a+b)^2-b^2 \\a^2+ab&amp;=&amp;a^2+2a\\frac{b}{2}+(\\frac{b}{2})^2-(\\frac{b}{2})^2&amp;=&amp;(a+\\frac{b}{2})^2-\\frac{b^2}{4} \\a^2+a\\Delta&amp;=&amp;a^2+2a\\frac{\\Delta}{2}+(\\frac{\\Delta}{2})^2-(\\frac{\\Delta}{2})^2&amp;=&amp;(a+\\frac{\\Delta}{2})^2-\\frac{\\Delta^2}{4} \\nonumber \n\n依次配方所有包含  的项\n\n当所有项都为完全平方项时，换元（以  为例$f=&amp;a(p_1x_1+q_1x_2+r_1x_3)^2+b(p_2x_1+q_2x_2+r_2x_3)^2+c(p_3x_1+q_3x_2+r_3x_3)^2\\&amp;\\rightarrow\\left{\\right.\\&amp;\\rightarrow\\left{\\right.$\n\n记 \n\n在线性代换  下，得到标准形：\n\n若  无法直接配方，先令：$$\\left{\\right.$$\n\n\n\n\n正交变化法：\n\n写出  的矩阵 \n求  的特征值 \n求  的特征向量 \n将特征向量中不正交向量的施密特正交化\n所有向量单位化得到 \n得到正交矩阵 \n记 ，\n在线性代换  下，得到标准形 \n\n\n\n\n正定二次型和正定矩阵\n\n概念：对任意 ，对实二次型  有 ，称  为正定二次型， 为正定矩阵\n\n 为实对称矩阵   正定\n\n二次型  正定 / 矩阵  正定的判定方法（主要）\n\n 的特征值全大于零（即  的正惯性指数==未知数个数）\n\n正惯性指数：标准形中正平方项的个数\n\n\n 的各阶顺序主子式皆大于零\n\n\n\n\n\n\n[1.7.x] 线性空间与线性变换\n线性空间\n\n定义： 是集合，  满足加法、数乘封闭\n\n基（类比向量组的极大无关组）\n\n 中能线性表示  中任意向量的向量组  是一组基\n\n\n维数（类比向量组的秩）\n\n 中一组基中包含向量的数目  是  的维数，记作 \n\n\n 维实向量空间\n\n所有  维实向量构成的集合，记作 \n 维基本向量组  是  一组基\neg.  一组基为 \n\n\n[Tip]任意  个线性无关的  维实向量一定能构成  一组基\n[Tip]方阵  满秩（），则  行/列向量一定能构成  一组基\n\n\n向量在基下的坐标\n\n设向量空间  有一组基 ，对于  中的任意向量 ，它可以表示为基向量的线性组合：\n  称  为向量  在基  下的坐标。\n\n[Tip]  有无数组基\n\n[Tip] 同一向量在一组基下坐标唯一，在不同基下坐标不同\n\n\n\n过渡矩阵\n\n同一向量空间下不同基变换使用的矩阵\n设  下有两组基 ，其向量组分别记为  ，则  是  到  的过渡矩阵\n若  在两组基下坐标分别为   称  或  为坐标变换公式\n\n\n向量的内积、长度和夹角\n\n设 \n内积：（点乘，相当于 ）\n，称  正交\n\n\n长度：\n\n单位向量：长度为1\n单位化：\n\n\n夹角：\n\n\n正交向量组与正交基\n\n正交向量组：一组非零且两两正交的向量组\n正交基：基为正交向量组\n标准正交基/规范正交基：基为正交向量组且每个基为单位向量\n\n\n向量组的正交化和单位化\n\n\n\n\n"},{"title":"Hello World","url":"/2022/10/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"故事的开始","url":"/2023/07/06/%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E5%A7%8B/","content":"写在前面\n从一个想法开始，花一个下午时间，在这个赛博世界，我也有了一隅冠以己名的桃花源。\n\n在故事的前言，我在这里记录维护这里的一些必要的操作，以防这些记忆迷失于未名的角落\n换言之，这是一份写给自己的使用说明\n关于驱动框架：HexoHexo 官网\n在 Hexo 对应根目录右键打开 Git Bash Here，使用 Git Bash 完成命令。\n初始化$ hexo init \n\n需要在空文件夹执行此命令，将克隆 Hexo 的启动配置包我们这里跳过这一步，直接使用 Keep 主题自带启动包\n本地生成与上线$ hexo n &quot;title&quot; # (new) 新建以 title 为标题的博客$ hexo clean     # 清除缓存和已生成的静态文件 public$ hexo g         # (generate) 生成网站静态文件$ hexo d         # (deploy) 推送本地 blog 到 github 仓库$ hexo s         # (server) 开启本地预览服务\n\n本地预览的地址一般是 http://localhost:4000/\n关于主题配置：Keep在 Keep 的中文开发文档中可以找到这个主题的一切指南。\n值得留意的是：\n\nHexo 配置文件目录：\\_config.yml\n\n主题配置文件目录：\\source\\_data\\keep.yml\n\n\n参考资料Hexo 最常用的几个命令\n2021最全hexo搭建博客+matery美化+使用\nKeep 主题使用指南 | XPoet’s Blog\n","categories":["Life"],"tags":["随笔"]}]